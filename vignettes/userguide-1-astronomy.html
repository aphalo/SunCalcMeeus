<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Pedro J. Aphalo" />

<meta name="date" content="2024-08-04" />

<title>User Guide: 1 Astronomy and Atmosphere</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">User Guide: 1 Astronomy and Atmosphere</h1>
<h3 class="subtitle">Package ‘photobiologySunCalc’ 0.1.0</h3>
<h4 class="author">Pedro J. Aphalo</h4>
<h4 class="date">2024-08-04</h4>


<div id="TOC">
<ul>
<li><a href="#radiation-astronomy-and-atmosphere" id="toc-radiation-astronomy-and-atmosphere">Radiation, astronomy and
atmosphere</a></li>
<li><a href="#getting-started" id="toc-getting-started">Getting
started</a></li>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#position-of-the-sun" id="toc-position-of-the-sun">Position
of the sun</a></li>
<li><a href="#times-of-sunrise-solar-noon-and-sunset" id="toc-times-of-sunrise-solar-noon-and-sunset">Times of sunrise, solar
noon and sunset</a></li>
<li><a href="#solar-time" id="toc-solar-time">Solar time</a></li>
<li><a href="#time-of-day" id="toc-time-of-day">Time of day</a></li>
<li><a href="#relative-air-mass" id="toc-relative-air-mass">Relative air
mass</a></li>
<li><a href="#water-vapour-related-calculations" id="toc-water-vapour-related-calculations">Water vapour-related
calculations</a></li>
<li><a href="#reference-evapotranspiration" id="toc-reference-evapotranspiration">Reference
evapotranspiration</a></li>
</ul>
</div>

<div id="radiation-astronomy-and-atmosphere" class="section level2">
<h2>Radiation, astronomy and atmosphere</h2>
<p>The functions described here used to be part of package
‘photobiology’, but as of version 0.11.3 have been moved to this
package. To ensure backwards compatibility, package ‘photobiology’
depends on ‘photobiologySunCalc’.</p>
</div>
<div id="getting-started" class="section level2">
<h2>Getting started</h2>
<p>We load two packages, our ‘<strong>photobiologySunCalc</strong>’ and
‘<strong>lubridate</strong>’, as they will be used in the examples.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(photobiologySunCalc)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(lubridate)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co"># if installed, we use &#39;lutz&#39; to lookup time zones from geocodes</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>eval_lutz <span class="ot">&lt;-</span> <span class="fu">requireNamespace</span>(<span class="st">&quot;lutz&quot;</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="cf">if</span> (eval_lutz) {<span class="fu">library</span>(lutz)}</span></code></pre></div>
</div>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Most organisms, including plants and animals, have circadian internal
clocks. These clocks are entrained to the day-night cycle through
perception of light. For example, night length informs plants about
seasons of the year. This information allows the synchronization of
developmental events like flowering to take place at the “right” time of
the year.</p>
<p>From the point of view of interactions between light and vegetation,
the direction of the direct light beam is of interest. Hence, the
position of the sun in the sky is also important for photobiology. This
is the reason for the inclusion of astronomical calculations about the
sun in this package. On the other hand, such calculations are also
highly relevant to other fields including solar energy.</p>
<p>The functions and methods described in this volume return either
values that represent angles or times. In the current version angles are
always expressed in degrees. In the case of times, the unit of
expression, can be changed through parameter <code>unit.out</code> which
accepts the following arguments <code>&quot;datetime&quot;</code>,
<code>&quot;hours&quot;</code>, <code>&quot;minutes&quot;</code>, <code>&quot;seconds&quot;</code>.
For backwards compatibility <code>&quot;date&quot;</code> is also accepted as
equivalent to <code>&quot;datetime&quot;</code> but deprecated.</p>
<p>All astronomical computations rely on the algorithms of Meuss (1998),
and consequently returned values are very precise. However, these
algorithms are computationally rather costly. Contrary to other faster
algorithms, they give reliable estimates even for latitudes near the
poles.</p>
<p>However, at high latitudes due to the almost tangential path of the
sun to the horizon, atmospheric effects that slightly alter the apparent
elevation of the sun have much larger effects on the apparent timing of
events given that the solar elevation angle changes at a slower rate
than at lower latitudes.</p>
</div>
<div id="position-of-the-sun" class="section level2">
<h2>Position of the sun</h2>
<p>The position of the sun at an arbitrary geographic locations and time
instant can be described with two angles: elevation above the horizon
and azimuth angle relative to the geographic North. If expressed in
degrees, solar elevation (<span class="math inline">\(h\)</span>) varies
between -90 and 90 degrees, while being visible when angles are positive
and otherwise occluded below the horizon. Azimuth angle (<span class="math inline">\(\alpha\)</span>) varies clockwise from North
between 0 and 360 degrees. Zenith angle (<span class="math inline">\(z\)</span>), provides the same information as the
elevation angle but using the zenith as starting point, consequently
taking values between 0 and 180 degrees, such that <span class="math inline">\(z = 90 - h\)</span>. Declination angle describes
the angle between the plane of the Equator and the plane of the Earth’s
orbit around the sun, and varies with the seasons of the year.</p>
<p>The function <code>sun_angles</code> returns location, civil time,
local solar time, the azimuth in degrees eastwards, elevation in degrees
above the horizon, declination, the equation of time and the hour
angle.</p>
<hr />
<p>In versions up to 0.9.11 of package ‘photobiology’ in addition to
parameter <code>geocode</code> most functions also had the redundant
formal parameters <code>lon</code> and <code>lat</code> which were
removed in version 0.9.12 released in October 2016.</p>
<hr />
<p>In versions 0.9.16 and later the code has been optimized for
performance with time vectors, making massive calculations such as the
sun position for every minute of the year quite fast (couple of
seconds). We keep, however, examples with rather short vectors.</p>
<hr />
<p>For calculation of the position of the sun we need to supply
geographic coordinates and a time instant. The time instant passed as
argument should be a <code>POSIXct</code> vector, possibly of length
one. The easiest way create date and time constant values is to use
package ‘lubridate’.</p>
<p>The object to be supplied as argument for <code>geocode</code> is a
data frame with variables <code>lon</code> and <code>lat</code> giving
the location on Earth. This matches the return value of functions
<code>tidygeocoder::geo_osm()</code>,
<code>tidygeocoder::geo_google()</code> and
<code>ggmap::geocode()</code>, functions that can be used to find the
coordinates using an <em>address</em> entered as a character string
understood by the OSM or Google maps APIs (Google requires an API key
and registration, while OSM is open). We use the “geocode” for Helsinki,
defined explicitly rather than searched for.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>my.geocode <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">lat =</span> <span class="fl">60.16</span>, <span class="at">lon =</span> <span class="fl">24.93</span>, <span class="at">address =</span> <span class="st">&quot;Helsinki&quot;</span>)</span></code></pre></div>
<p>Be aware that to obtain correct the time zone must be correctly set
for the argument passed to <code>time</code>. To obtain results based on
local time, this time zone needs to be set in the <code>POSIXct</code>
object or passed as a argument to <code>tz</code>. In the examples we
use functions from package ‘lubridate’ for working with times and dates.
The argument passed to parameter <code>time</code> can be a “vector” of
<code>POSIXct</code> values. The returned value is a
<code>data.frame</code>.</p>
<p>The position of the sun at Helsinki, at the given instant in time for
time zone <em>Eastern European Time</em>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">sun_angles</span>(<span class="at">time =</span> <span class="fu">ymd_hms</span>(<span class="st">&quot;2017-06-20 08:00:00&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>), <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## # A tibble: 1 × 12
##   time                tz    solartime  longitude latitude address  azimuth
##   &lt;dttm&gt;              &lt;chr&gt; &lt;solar_tm&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;
## 1 2017-06-20 08:00:00 EET   06:38:09        24.9     60.2 Helsinki    85.8
## # ℹ 5 more variables: elevation &lt;dbl&gt;, declination &lt;dbl&gt;, eq.of.time &lt;dbl&gt;,
## #   hour.angle &lt;dbl&gt;, distance &lt;dbl&gt;</code></pre>
<p>Functions have defaults for their arguments, but rarely Greenwich
will be the location you are interested in. Current UTC time is probably
a useful default in some cases.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">sun_angles</span>()</span></code></pre></div>
<pre><code>## # A tibble: 1 × 12
##   time                tz    solartime  longitude latitude address   azimuth
##   &lt;dttm&gt;              &lt;chr&gt; &lt;solar_tm&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;
## 1 2024-08-05 14:06:36 UTC   14:00:39           0     51.5 Greenwich    226.
## # ℹ 5 more variables: elevation &lt;dbl&gt;, declination &lt;dbl&gt;, eq.of.time &lt;dbl&gt;,
## #   hour.angle &lt;dbl&gt;, distance &lt;dbl&gt;</code></pre>
<p>A vector of times is accepted as argument, and as performance is
optimized for this case, <em>vectorization</em> will markedly improve
performance compared to multiple calls to the function. The vector of
times can be created on the fly, or stored beforehand.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">sun_angles</span>(<span class="at">time =</span> <span class="fu">ymd_hms</span>(<span class="st">&quot;2014-01-01 0:0:0&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>) <span class="sc">+</span> <span class="fu">hours</span>(<span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">6</span>, <span class="dv">12</span>)), </span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>           <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 12
##   time                tz    solartime  longitude latitude address  azimuth
##   &lt;dttm&gt;              &lt;chr&gt; &lt;solar_tm&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;
## 1 2014-01-01 00:00:00 EET   23:36:26        24.9     60.2 Helsinki   351. 
## 2 2014-01-01 06:00:00 EET   05:36:19        24.9     60.2 Helsinki    97.0
## 3 2014-01-01 12:00:00 EET   11:36:12        24.9     60.2 Helsinki   174. 
## # ℹ 5 more variables: elevation &lt;dbl&gt;, declination &lt;dbl&gt;, eq.of.time &lt;dbl&gt;,
## #   hour.angle &lt;dbl&gt;, distance &lt;dbl&gt;</code></pre>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>my.times <span class="ot">&lt;-</span> <span class="fu">ymd_hms</span>(<span class="st">&quot;2014-01-01 0:0:0&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>) <span class="sc">+</span> <span class="fu">hours</span>(<span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">6</span>, <span class="dv">12</span>))</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="fu">sun_angles</span>(<span class="at">time =</span> my.times, <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 12
##   time                tz    solartime  longitude latitude address  azimuth
##   &lt;dttm&gt;              &lt;chr&gt; &lt;solar_tm&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;
## 1 2014-01-01 00:00:00 EET   23:36:26        24.9     60.2 Helsinki   351. 
## 2 2014-01-01 06:00:00 EET   05:36:19        24.9     60.2 Helsinki    97.0
## 3 2014-01-01 12:00:00 EET   11:36:12        24.9     60.2 Helsinki   174. 
## # ℹ 5 more variables: elevation &lt;dbl&gt;, declination &lt;dbl&gt;, eq.of.time &lt;dbl&gt;,
## #   hour.angle &lt;dbl&gt;, distance &lt;dbl&gt;</code></pre>
<p>Geocodes for several locations can be stored in a data frame with
multiple rows.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>two.geocodes <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">lat =</span> <span class="fu">c</span>(<span class="fl">60.16</span>, <span class="fl">65.02</span>), </span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>                           <span class="at">lon =</span> <span class="fu">c</span>(<span class="fl">24.93</span>, <span class="fl">25.47</span>),</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>                           <span class="at">address =</span> <span class="fu">c</span>(<span class="st">&quot;Helsinki&quot;</span>, <span class="st">&quot;Oulu&quot;</span>))</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="fu">sun_angles</span>(<span class="at">time =</span> my.times, <span class="at">geocode =</span> two.geocodes)</span></code></pre></div>
<pre><code>## # A tibble: 6 × 12
##   time                tz    solartime  longitude latitude address  azimuth
##   &lt;dttm&gt;              &lt;chr&gt; &lt;solar_tm&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;
## 1 2014-01-01 00:00:00 EET   23:36:26        24.9     60.2 Helsinki   351. 
## 2 2014-01-01 06:00:00 EET   05:36:19        24.9     60.2 Helsinki    97.0
## 3 2014-01-01 12:00:00 EET   11:36:12        24.9     60.2 Helsinki   174. 
## 4 2014-01-01 00:00:00 EET   23:38:36        25.5     65.0 Oulu       353. 
## 5 2014-01-01 06:00:00 EET   05:38:29        25.5     65.0 Oulu        95.4
## 6 2014-01-01 12:00:00 EET   11:38:22        25.5     65.0 Oulu       175. 
## # ℹ 5 more variables: elevation &lt;dbl&gt;, declination &lt;dbl&gt;, eq.of.time &lt;dbl&gt;,
## #   hour.angle &lt;dbl&gt;, distance &lt;dbl&gt;</code></pre>
<p>When spectra contain suitable metadata, the position of the sun for
the spectral irradiance data measurement can be easily obtained.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">sun_angles</span>(<span class="at">time =</span> photobiology<span class="sc">::</span><span class="fu">getWhenMeasured</span>(sun.spct), </span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>           <span class="at">eocode =</span> photobiology<span class="sc">::</span><span class="fu">getWhereMeasured</span>(sun.spct))</span></code></pre></div>
<p>If what is needed is only one of the solar angles, functions
returning vectors instead of data frames can be useful. (In their
current implementation these functions <em>do not</em> have improved
performance compared to <code>sun_angles()</code>)</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">sun_elevation</span>(<span class="at">time =</span> my.times, <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] -52.639345 -22.722495   6.710245</code></pre>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">sun_zenith_angle</span>(<span class="at">time =</span> my.times, <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] 142.63935 112.72250  83.28976</code></pre>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="fu">sun_azimuth</span>(<span class="at">time =</span> my.times, <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] 351.04757  96.98377 174.48767</code></pre>
</div>
<div id="times-of-sunrise-solar-noon-and-sunset" class="section level2">
<h2>Times of sunrise, solar noon and sunset</h2>
<p>Convenience functions <code>sunrise_time()</code>,
<code>sunset_time()</code>, <code>noon_time()</code>,
<code>day_length()</code> and <code>night_length()</code> have all the
same parameter signature and are wrappers on function
<code>day_night()</code>. Function <code>day_night</code> returns a data
frame containing all the quantities returned by the other functions.</p>
<p>These functions are vectorized for their <code>date</code> and
<code>geocode</code> parameters. They use as default location Greenwich
in the U.K., and default time zone “UTC”. The date is given by default
by the current date based on “UTC”. Universal Time Coordinate (“UTC”) is
the reference used to describe differences among time zones and is never
modified by daylight saving time or summer time. The difference between
EET (Eastern European Time) and UTC is +2 hours in winter and with EEST
(Eastern European Summer Time) +3 hours.</p>
<p>Latitude and longitude are passed through a <code>geocode</code> (a
data frame). If the returned value is desired in the local time
coordinates of the argument passed to <code>geocode</code>, the time
zone should match the geographic coordinates. If geocodes contain a
variable <code>&quot;address&quot;</code> it will be copied to the output.</p>
<p>In some of the examples below we reuse the geocode data frames
created above, and we here create a vector of datetime objects differing
in their date. The default time zone of function <code>ymd()</code> is
<code>NULL</code>, so we override it with <code>EET</code> to match the
geocodes for Finnish cities.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>dates <span class="ot">&lt;-</span> <span class="fu">ymd</span>(<span class="st">&quot;2015-03-01&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>) <span class="sc">+</span> <span class="fu">months</span>(<span class="dv">0</span><span class="sc">:</span><span class="dv">5</span>)</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>dates</span></code></pre></div>
<pre><code>## [1] &quot;2015-03-01 EET&quot;  &quot;2015-04-01 EEST&quot; &quot;2015-05-01 EEST&quot; &quot;2015-06-01 EEST&quot;
## [5] &quot;2015-07-01 EEST&quot; &quot;2015-08-01 EEST&quot;</code></pre>
<p>As first example we compute the sunrise time for the current day in
Helsinki, with the result returned eithe in UTC or EET coordinates.
Time-zone names based on continent and city are also supported, and are
to be preferred for past dates and the relationship between time zones
and locations are affected by changes in country boundaries and in
national laws.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(<span class="fu">now</span>(<span class="st">&quot;UTC&quot;</span>), <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] &quot;2024-08-05 02:11:19 UTC&quot;</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(<span class="fu">now</span>(<span class="st">&quot;EET&quot;</span>), <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] &quot;2024-08-05 05:11:19 EEST&quot;</code></pre>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(<span class="fu">now</span>(<span class="st">&quot;Europe/Helsinki&quot;</span>), <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] &quot;2024-08-05 05:11:19 EEST&quot;</code></pre>
<hr />
<p>Be aware of the behaviour of functions <code>ymd()</code>,
<code>dmy()</code>, <code>ym()</code> and <code>my()</code> from package
‘lubridate’. A function call like
<code>ymd(&quot;2015-03-01&quot;, tz = &quot;UTC&quot;)</code> returns a
<code>POSIXct</code> object while a call like
<code>ymd(&quot;2015-03-01&quot;)</code> is equivalent to
<code>ymd(&quot;2015-03-01&quot;, tz = NULL)</code> and returns a
<code>Date</code> object. <code>Date</code> objects do not carry time
zone information in the way <code>POSIXct</code> objects do, and
consequently <code>Dates</code> do not uniquely match a period between
two absolute instants in time, but rather between two instants in local
time. Given these features, it is safer to use <code>POSIXct</code>
objects as arguments to the functions from package ‘photobiology’.
Function <code>today()</code> always returns a <code>Date</code> while
function <code>now()</code> always returns a <code>POSIXct</code>,
independently of the argument passed to their <code>tzone</code>
parameter. Consequently it is preferable to use <code>now()</code>, but
if you do use <code>today()</code> make sure to path the same value as
argument to parameter <code>tzone</code> of <code>today()</code> and to
parameter <code>tz</code> of the functions from package ‘photobiology’.
<em>An instant in time and time zone strictly define a corresponding
date at any location on Earth.</em></p>
<p>The default for time zone is that of the <code>POSIXct</code> value
passed as argument to parameter <code>date</code>, but this can be
overridden.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(<span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] &quot;2024-08-05 02:11:19 UTC&quot;</code></pre>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(<span class="at">date =</span> <span class="fu">now</span>(<span class="st">&quot;UTC&quot;</span>), <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] &quot;2024-08-05 02:11:19 UTC&quot;</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(<span class="at">date =</span> <span class="fu">now</span>(<span class="st">&quot;UTC&quot;</span>), <span class="at">tz =</span> <span class="st">&quot;UTC&quot;</span>, <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] &quot;2024-08-05 02:11:19 UTC&quot;</code></pre>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(<span class="at">date =</span> <span class="fu">now</span>(<span class="st">&quot;EET&quot;</span>), <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] &quot;2024-08-05 05:11:19 EEST&quot;</code></pre>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(<span class="at">date =</span> <span class="fu">now</span>(<span class="st">&quot;EET&quot;</span>), <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>, <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] &quot;2024-08-05 05:11:19 EEST&quot;</code></pre>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(<span class="fu">today</span>(<span class="st">&quot;EET&quot;</span>), <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>, <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] &quot;2024-08-05 05:11:19 EEST&quot;</code></pre>
<hr />
<p>We can also compute the time of solar noon and of sunset.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a><span class="fu">noon_time</span>(<span class="fu">now</span>(<span class="st">&quot;UTC&quot;</span>), <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] &quot;2024-08-05 10:26:15 UTC&quot;</code></pre>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a><span class="fu">noon_time</span>(<span class="fu">now</span>(<span class="st">&quot;EET&quot;</span>), <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] &quot;2024-08-05 13:26:15 EEST&quot;</code></pre>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="fu">sunset_time</span>(<span class="fu">now</span>(<span class="st">&quot;UTC&quot;</span>), <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] &quot;2024-08-05 18:41:10 UTC&quot;</code></pre>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="fu">sunset_time</span>(<span class="fu">now</span>(<span class="st">&quot;EET&quot;</span>), <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] &quot;2024-08-05 21:41:10 EEST&quot;</code></pre>
<p>Functions <code>day_length()</code> and <code>night_length()</code>
return the length of time, by default in hours and fraction.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a><span class="fu">day_length</span>(dates, <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] 10.34596 13.19241 15.90766 18.27962 18.80811 16.97567</code></pre>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a><span class="fu">night_length</span>(dates, <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] 13.654040 10.807592  8.092343  5.720384  5.191888  7.024327</code></pre>
<p>Southern hemisphere latitudes as well as longitudes to the West of
the Greenwich meridian should be supplied as negative numbers.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(dates, <span class="at">geocode =</span> <span class="fu">data.frame</span>(<span class="at">lat =</span> <span class="dv">60</span>, <span class="at">lon =</span> <span class="dv">25</span>))</span></code></pre></div>
<pre><code>## [1] &quot;2015-02-28 07:21:52 EET&quot;  &quot;2015-03-31 06:48:41 EEST&quot;
## [3] &quot;2015-04-30 05:20:50 EEST&quot; &quot;2015-05-31 04:10:49 EEST&quot;
## [5] &quot;2015-06-30 04:01:10 EEST&quot; &quot;2015-07-31 04:58:15 EEST&quot;</code></pre>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="fu">noon_time</span>(dates, <span class="at">geocode =</span> <span class="fu">data.frame</span>(<span class="at">lat =</span> <span class="dv">60</span>, <span class="at">lon =</span> <span class="dv">25</span>))</span></code></pre></div>
<pre><code>## [1] &quot;2015-02-28 12:32:34 EET&quot;  &quot;2015-03-31 13:24:14 EEST&quot;
## [3] &quot;2015-04-30 13:17:15 EEST&quot; &quot;2015-05-31 13:17:38 EEST&quot;
## [5] &quot;2015-06-30 13:23:36 EEST&quot; &quot;2015-07-31 13:26:24 EEST&quot;</code></pre>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(dates, <span class="at">geocode =</span> <span class="fu">data.frame</span>(<span class="at">lat =</span> <span class="sc">-</span><span class="dv">60</span>, <span class="at">lon =</span> <span class="dv">25</span>))</span></code></pre></div>
<pre><code>## [1] &quot;2015-02-28 05:29:25 EET&quot;  &quot;2015-03-31 07:46:18 EEST&quot;
## [3] &quot;2015-04-30 08:58:10 EEST&quot; &quot;2015-05-31 10:04:25 EEST&quot;
## [5] &quot;2015-06-30 10:24:25 EEST&quot; &quot;2015-07-31 09:37:27 EEST&quot;</code></pre>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a><span class="fu">noon_time</span>(dates, <span class="at">geocode =</span> <span class="fu">data.frame</span>(<span class="at">lat =</span> <span class="sc">-</span><span class="dv">60</span>, <span class="at">lon =</span> <span class="dv">25</span>))</span></code></pre></div>
<pre><code>## [1] &quot;2015-02-28 12:32:34 EET&quot;  &quot;2015-03-31 13:24:14 EEST&quot;
## [3] &quot;2015-04-30 13:17:15 EEST&quot; &quot;2015-05-31 13:17:38 EEST&quot;
## [5] &quot;2015-06-30 13:23:36 EEST&quot; &quot;2015-07-31 13:26:24 EEST&quot;</code></pre>
<p>The angle used in the twilight calculation can be supplied, either as
the name of a standard definition, or as an angle in degrees (negative
for sun positions below the horizon). Positive angles can be used when
the time of sun occlusion behind a building, mountain, or other obstacle
needs to be calculated. The default for <code>twilight</code> is
<code>&quot;none&quot;</code> meaning that times correspond to the occlusion of
the upper rim of the sun disk below the theoretical horizon.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(<span class="fu">ymd</span>(<span class="st">&quot;2017-03-21&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>), </span>
<span id="cb60-2"><a href="#cb60-2" tabindex="-1"></a>             <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>, </span>
<span id="cb60-3"><a href="#cb60-3" tabindex="-1"></a>             <span class="at">geocode =</span> my.geocode,</span>
<span id="cb60-4"><a href="#cb60-4" tabindex="-1"></a>             <span class="at">twilight =</span> <span class="st">&quot;civil&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;2017-03-20 05:38:58 EET&quot;</code></pre>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(<span class="fu">ymd</span>(<span class="st">&quot;2017-03-21&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>), </span>
<span id="cb62-2"><a href="#cb62-2" tabindex="-1"></a>             <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>, </span>
<span id="cb62-3"><a href="#cb62-3" tabindex="-1"></a>             <span class="at">geocode =</span> my.geocode,</span>
<span id="cb62-4"><a href="#cb62-4" tabindex="-1"></a>             <span class="at">twilight =</span> <span class="sc">-</span><span class="dv">10</span>)</span></code></pre></div>
<pre><code>## [1] &quot;2017-03-20 05:05:45 EET&quot;</code></pre>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(<span class="fu">ymd</span>(<span class="st">&quot;2017-03-21&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>), </span>
<span id="cb64-2"><a href="#cb64-2" tabindex="-1"></a>             <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>, </span>
<span id="cb64-3"><a href="#cb64-3" tabindex="-1"></a>             <span class="at">geocode =</span> my.geocode,</span>
<span id="cb64-4"><a href="#cb64-4" tabindex="-1"></a>             <span class="at">twilight =</span> <span class="sc">+</span><span class="dv">12</span>)</span></code></pre></div>
<pre><code>## [1] &quot;2017-03-20 08:06:15 EET&quot;</code></pre>
<p>Parameter <code>unit.out</code> can be used to obtain the returned
value expressed as time-of-day in hours, minutes, or seconds since
midnight, instead of the default <code>datetime</code>.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(<span class="fu">ymd</span>(<span class="st">&quot;2017-03-21&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>), </span>
<span id="cb66-2"><a href="#cb66-2" tabindex="-1"></a>             <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>, </span>
<span id="cb66-3"><a href="#cb66-3" tabindex="-1"></a>             <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## [1] &quot;2017-03-20 06:20:46 EET&quot;</code></pre>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a><span class="fu">sunrise_time</span>(<span class="fu">ymd</span>(<span class="st">&quot;2017-03-21&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>), </span>
<span id="cb68-2"><a href="#cb68-2" tabindex="-1"></a>             <span class="at">tz =</span> <span class="st">&quot;EET&quot;</span>, </span>
<span id="cb68-3"><a href="#cb68-3" tabindex="-1"></a>             <span class="at">geocode =</span> my.geocode,</span>
<span id="cb68-4"><a href="#cb68-4" tabindex="-1"></a>             <span class="at">unit.out =</span> <span class="st">&quot;hours&quot;</span>)</span></code></pre></div>
<pre><code>## [1] 6.346365</code></pre>
<p>Similarly, the units can also be selected for the values returned by
<code>day_length()</code> and <code>night_length()</code>.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" tabindex="-1"></a><span class="fu">day_length</span>(dates, <span class="at">geocode =</span> my.geocode, <span class="at">unit.out =</span> <span class="st">&quot;days&quot;</span>)</span></code></pre></div>
<pre><code>## [1] 0.4310817 0.5496837 0.6628190 0.7616507 0.7836713 0.7073197</code></pre>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" tabindex="-1"></a><span class="fu">night_length</span>(dates, <span class="at">geocode =</span> my.geocode, <span class="at">unit.out =</span> <span class="st">&quot;days&quot;</span>)</span></code></pre></div>
<pre><code>## [1] 0.5689183 0.4503163 0.3371810 0.2383493 0.2163287 0.2926803</code></pre>
<hr />
<p>The core function is called <code>day_night()</code> and returns a
data frame containing both the input values and the results of the
calculations. See above for convenience functions useful in the case one
needs only one of the calculated variables. In other cases it is more
efficient to compute the whole data frame and later select the columns
of interest.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" tabindex="-1"></a><span class="fu">day_night</span>(dates[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>], </span>
<span id="cb74-2"><a href="#cb74-2" tabindex="-1"></a>          <span class="at">geocode =</span> my.geocode)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 12
##   day                 tz    twilight.rise twilight.set longitude latitude
##   &lt;dttm&gt;              &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
## 1 2015-02-28 00:00:00 EET               0            0      24.9     60.2
## 2 2015-03-31 00:00:00 EET               0            0      24.9     60.2
## 3 2015-04-30 00:00:00 EET               0            0      24.9     60.2
## # ℹ 6 more variables: address &lt;chr&gt;, sunrise &lt;dbl&gt;, noon &lt;dbl&gt;, sunset &lt;dbl&gt;,
## #   daylength &lt;dbl&gt;, nightlength &lt;dbl&gt;</code></pre>
<p>The default for <code>unit.out</code> is <code>&quot;hours&quot;</code> with
decimal fractions, as seen above. However other useful units like
<code>&quot;seconds&quot;</code>, <code>&quot;minutes&quot;</code>, and <code>&quot;days&quot;</code>
can be useful.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" tabindex="-1"></a><span class="fu">day_night</span>(dates[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>], </span>
<span id="cb76-2"><a href="#cb76-2" tabindex="-1"></a>          <span class="at">geocode =</span> my.geocode, </span>
<span id="cb76-3"><a href="#cb76-3" tabindex="-1"></a>          <span class="at">unit.out =</span> <span class="st">&quot;days&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 12
##   day                 tz    twilight.rise twilight.set longitude latitude
##   &lt;dttm&gt;              &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
## 1 2015-02-28 00:00:00 EET               0            0      24.9     60.2
## 2 2015-03-31 00:00:00 EET               0            0      24.9     60.2
## 3 2015-04-30 00:00:00 EET               0            0      24.9     60.2
## # ℹ 6 more variables: address &lt;chr&gt;, sunrise &lt;dbl&gt;, noon &lt;dbl&gt;, sunset &lt;dbl&gt;,
## #   daylength &lt;dbl&gt;, nightlength &lt;dbl&gt;</code></pre>
<p>Finally it is also possible to have the timing of solar events
returned as <code>POSIXct</code> time values, in which case lengths of
time are still returned as fractional hours.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" tabindex="-1"></a><span class="fu">day_night</span>(dates[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>], </span>
<span id="cb78-2"><a href="#cb78-2" tabindex="-1"></a>          <span class="at">geocode =</span> my.geocode, </span>
<span id="cb78-3"><a href="#cb78-3" tabindex="-1"></a>          <span class="at">unit.out =</span> <span class="st">&quot;datetime&quot;</span>)</span></code></pre></div>
<pre><code>## # A tibble: 3 × 12
##   day                 tz    twilight.rise twilight.set longitude latitude
##   &lt;dttm&gt;              &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
## 1 2015-02-28 00:00:00 EET               0            0      24.9     60.2
## 2 2015-03-31 00:00:00 EET               0            0      24.9     60.2
## 3 2015-04-30 00:00:00 EET               0            0      24.9     60.2
## # ℹ 6 more variables: address &lt;chr&gt;, sunrise &lt;dttm&gt;, noon &lt;dttm&gt;,
## #   sunset &lt;dttm&gt;, daylength &lt;dbl&gt;, nightlength &lt;dbl&gt;</code></pre>
<p>When multiple times and locations are supplied as arguments, the
values returned are for all combinations of locations and times.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" tabindex="-1"></a><span class="fu">day_night</span>(dates[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>], </span>
<span id="cb80-2"><a href="#cb80-2" tabindex="-1"></a>          <span class="at">geocode =</span> two.geocodes)</span></code></pre></div>
<pre><code>## # A tibble: 6 × 12
##   day                 tz    twilight.rise twilight.set longitude latitude
##   &lt;dttm&gt;              &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
## 1 2015-02-28 00:00:00 EET               0            0      24.9     60.2
## 2 2015-03-31 00:00:00 EET               0            0      24.9     60.2
## 3 2015-04-30 00:00:00 EET               0            0      24.9     60.2
## 4 2015-02-28 00:00:00 EET               0            0      25.5     65.0
## 5 2015-03-31 00:00:00 EET               0            0      25.5     65.0
## 6 2015-04-30 00:00:00 EET               0            0      25.5     65.0
## # ℹ 6 more variables: address &lt;chr&gt;, sunrise &lt;dbl&gt;, noon &lt;dbl&gt;, sunset &lt;dbl&gt;,
## #   daylength &lt;dbl&gt;, nightlength &lt;dbl&gt;</code></pre>
</div>
<div id="solar-time" class="section level2">
<h2>Solar time</h2>
<p>In field research it is in many cases preferable to sample or
measure, and present and plot data based on local solar time. A new
class is defined in package ‘photobiology’, with a print method, a
constructor, a conversion function and a class query function.</p>
<p>The constructor takes as arguments a <code>POSIXct</code> object
describing and instant in time and a geocode describing the geographic
coordinates.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" tabindex="-1"></a>Paris.geo <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">lon =</span> <span class="fl">2.352222</span>, <span class="at">lat =</span> <span class="fl">48.85661</span>, <span class="at">address =</span> <span class="st">&quot;Paris&quot;</span>)</span>
<span id="cb82-2"><a href="#cb82-2" tabindex="-1"></a>Paris.time <span class="ot">&lt;-</span> <span class="fu">ymd_hms</span>(<span class="st">&quot;2016-09-30 06:00:00&quot;</span>, <span class="at">tz =</span> <span class="st">&quot;UTC&quot;</span>)</span>
<span id="cb82-3"><a href="#cb82-3" tabindex="-1"></a><span class="fu">solar_time</span>(Paris.time, <span class="at">geocode =</span> Paris.geo)</span></code></pre></div>
<pre><code>## [1] &quot;06:19:28&quot;</code></pre>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" tabindex="-1"></a><span class="fu">solar_time</span>(Paris.time, <span class="at">geocode =</span> Paris.geo, <span class="at">unit.out =</span> <span class="st">&quot;datetime&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;2016-09-30 06:19:28 solar&quot;</code></pre>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" tabindex="-1"></a>my.solar.t <span class="ot">&lt;-</span> <span class="fu">solar_time</span>(Paris.time, <span class="at">geocode =</span> Paris.geo)</span>
<span id="cb86-2"><a href="#cb86-2" tabindex="-1"></a><span class="fu">is.solar_time</span>(my.solar.t)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" tabindex="-1"></a><span class="fu">is.numeric</span>(my.solar.t)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" tabindex="-1"></a>my.solar.d <span class="ot">&lt;-</span> <span class="fu">solar_time</span>(Paris.time, <span class="at">geocode =</span> Paris.geo, <span class="at">unit.out =</span> <span class="st">&quot;datetime&quot;</span>)</span>
<span id="cb90-2"><a href="#cb90-2" tabindex="-1"></a><span class="fu">is.solar_date</span>(my.solar.d)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" tabindex="-1"></a><span class="fu">is.timepoint</span>(my.solar.d)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="time-of-day" class="section level2">
<h2>Time of day</h2>
<p>Function <code>as_tod()</code> facilitates conversion of R’s time
date objects into a numeric value representing the time of day as
numerical value with a decimal fraction using one of hour, minute or
second as unit of expression. While solar time is based on the
astronomical position of the sun, time of day is based on the time
coordinates for a time zone.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1" tabindex="-1"></a>times <span class="ot">&lt;-</span> <span class="fu">now</span>(<span class="at">tzone =</span> <span class="st">&quot;UTC&quot;</span>) <span class="sc">+</span> <span class="fu">hours</span>(<span class="dv">0</span><span class="sc">:</span><span class="dv">6</span>)</span>
<span id="cb94-2"><a href="#cb94-2" tabindex="-1"></a>times</span></code></pre></div>
<pre><code>## [1] &quot;2024-08-05 14:06:38 UTC&quot; &quot;2024-08-05 15:06:38 UTC&quot;
## [3] &quot;2024-08-05 16:06:38 UTC&quot; &quot;2024-08-05 17:06:38 UTC&quot;
## [5] &quot;2024-08-05 18:06:38 UTC&quot; &quot;2024-08-05 19:06:38 UTC&quot;
## [7] &quot;2024-08-05 20:06:38 UTC&quot;</code></pre>
<div class="sourceCode" id="cb96"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1" tabindex="-1"></a><span class="fu">as_tod</span>(times)</span></code></pre></div>
<pre><code>## [1] 14.11063 15.11063 16.11063 17.11063 18.11063 19.11063 20.11063</code></pre>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" tabindex="-1"></a><span class="fu">as_tod</span>(times, <span class="at">unit.out =</span> <span class="st">&quot;minutes&quot;</span>)</span></code></pre></div>
<pre><code>## [1]  846.6378  906.6378  966.6378 1026.6378 1086.6378 1146.6378 1206.6378</code></pre>
</div>
<div id="relative-air-mass" class="section level2">
<h2>Relative air mass</h2>
<p>Solar elevation determines the length of the path of the sun beam
through the Earth’s atmosphere. This affects the solar spectrum at
ground level, specially the UVB region. Function
<code>relative_AM()</code> can be used to calculate an empirical
<em>estimate</em> of this quantity from elevation angles in degrees.
This function is vectorised.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" tabindex="-1"></a><span class="fu">relative_AM</span>(<span class="dv">33</span>)</span></code></pre></div>
<pre><code>## [1] 1.83</code></pre>
<div class="sourceCode" id="cb102"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" tabindex="-1"></a><span class="fu">relative_AM</span>(<span class="fu">c</span>(<span class="dv">80</span>, <span class="dv">60</span>, <span class="dv">40</span>, <span class="dv">20</span>))</span></code></pre></div>
<pre><code>## [1] 1.01 1.15 1.55 2.90</code></pre>
</div>
<div id="water-vapour-related-calculations" class="section level2">
<h2>Water vapour-related calculations</h2>
<p>There are several different empirical equations in common use to
estimate water vapour pressure in air over liquid water or ice. This
package implements some of them as well as their inverses, which are
useful to compute the dew point. Some ancillary functions help with unit
conversion and computation of relative humidity.</p>
<table>
<colgroup>
<col width="16%" />
<col width="14%" />
<col width="19%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">parameters</th>
<th align="left">returned value</th>
<th align="left">methods implemented</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">water_vp_sat()</td>
<td align="left">temperature, C</td>
<td align="left">vapour pressure, Pa</td>
<td align="left">Tetens, Magnus, Wexler, Goff-Gratch</td>
</tr>
<tr class="even">
<td align="left">water_dp()</td>
<td align="left">vapour pressure, Pa</td>
<td align="left">temperature, C</td>
<td align="left">Tetens, Magnus, Wexler</td>
</tr>
<tr class="odd">
<td align="left">water_fp()</td>
<td align="left">vapour pressure, Pa</td>
<td align="left">temperature, C</td>
<td align="left">Tetens, Magnus, Wexler</td>
</tr>
<tr class="even">
<td align="left">water_vp2RH()</td>
<td align="left">vapour pressure, Pa; temperature, C</td>
<td align="left">relative humidity, %</td>
<td align="left">Tetens, Magnus, Wexler, Goff-Gratch</td>
</tr>
<tr class="odd">
<td align="left">water_RH2vp()</td>
<td align="left">relative humidity, %; temperature, C</td>
<td align="left">vapour pressure, Pa</td>
<td align="left">Tetens, Magnus, Wexler, Goff-Gratch</td>
</tr>
<tr class="even">
<td align="left">water_vp2mvc()</td>
<td align="left">vapour pressure, Pa</td>
<td align="left">mass/vol. concentration, g m<span class="math inline">\(^{-3}\)</span></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">water_mvc2vp()</td>
<td align="left">mass/vol. concentration, g m<span class="math inline">\(^{-3}\)</span></td>
<td align="left">vapour pressure, Pa</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>Saturation vapour pressure in Pa at four air temperatures in C, over
water, computed using Tetens equation (the default method).</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1" tabindex="-1"></a><span class="fu">water_vp_sat</span>(<span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>))</span></code></pre></div>
<pre><code>## [1]  610.780 1227.873 2338.023 4242.450</code></pre>
<p>Saturation water vapour mass/volume concentration for air at 20 C,
expressed in grammes per cubic meter.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb106-1"><a href="#cb106-1" tabindex="-1"></a><span class="fu">water_vp2mvc</span>(<span class="fu">water_vp_sat</span>(<span class="dv">20</span>), <span class="dv">20</span>)</span></code></pre></div>
<pre><code>## [1] 17.27438</code></pre>
<p>Vapour pressure for 50% relative humidity in air at a temperature of
20 C.</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb108-1"><a href="#cb108-1" tabindex="-1"></a><span class="fu">water_RH2vp</span>(<span class="dv">50</span>, <span class="dv">20</span>)</span></code></pre></div>
<pre><code>## [1] 1169.011</code></pre>
<p>And the inverse computation, RH from vapour pressure in Pa and air
temperature in C.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb110-1"><a href="#cb110-1" tabindex="-1"></a><span class="fu">water_vp2RH</span>(<span class="dv">500</span>, <span class="dv">40</span>)</span></code></pre></div>
<pre><code>## [1] 6.780297</code></pre>
<p>Dew point for air with a water vapour pressure of 3 kPa.</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb112-1"><a href="#cb112-1" tabindex="-1"></a><span class="fu">water_dp</span>(<span class="dv">3000</span>)</span></code></pre></div>
<pre><code>## [1] 24.09167</code></pre>
</div>
<div id="reference-evapotranspiration" class="section level2">
<h2>Reference evapotranspiration</h2>
<p>Evapotranspiration is a measure of the water flux between land and
atmosphere expressed as millimeters of water per unit ground area and
unit time. One millimeter of evapotranspiration or precipitation is
equivalent to one litre per square meter. Evapotranspiration is composed
of the evaporation from the soil surface and other wet surfaces plus
transpiration from plants (water evaporated inside leaves and diffusing
as vapour to the outside of leaves). The condensation of dew represents
a negative component.</p>
<p>When not measured, evapotranspiration can be estimated based on
energy balance and resistances to mass and heat transport. The
Penman-Monteith equation is widely used. One special idealized condition
is used to compute reference evapotranspiration (similar to potential
evapotranspiration but with a standardized formulation by FAO that is
widely used in agriculture).</p>
<p>As implemented the computation of the energy balance is done with
function <code>net_irradiance()</code> and using the value returned by
this function as one argument, reference evapotranspiration is computed
with function <code>ET_ref()</code>.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1" tabindex="-1"></a>r_net <span class="ot">&lt;-</span> <span class="fu">net_irradiance</span>(<span class="at">temperature =</span> <span class="dv">20</span>, <span class="co"># C</span></span>
<span id="cb114-2"><a href="#cb114-2" tabindex="-1"></a>                        <span class="at">sw.down.irradiance =</span> <span class="dv">800</span>, <span class="co"># W / m2</span></span>
<span id="cb114-3"><a href="#cb114-3" tabindex="-1"></a>                        <span class="at">water.vp =</span> <span class="dv">1500</span>) <span class="co"># Pa</span></span>
<span id="cb114-4"><a href="#cb114-4" tabindex="-1"></a>r_net <span class="co"># W / m2</span></span></code></pre></div>
<pre><code>## [1] 546.8251</code></pre>
<div class="sourceCode" id="cb116"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb116-1"><a href="#cb116-1" tabindex="-1"></a><span class="fu">ET_ref</span>(<span class="at">temperature =</span> <span class="dv">20</span>, <span class="co"># C</span></span>
<span id="cb116-2"><a href="#cb116-2" tabindex="-1"></a>       <span class="at">water.vp =</span> <span class="dv">1500</span>, <span class="co"># Pa</span></span>
<span id="cb116-3"><a href="#cb116-3" tabindex="-1"></a>       <span class="at">wind.speed =</span> <span class="dv">4</span>, <span class="co"># m / s</span></span>
<span id="cb116-4"><a href="#cb116-4" tabindex="-1"></a>       <span class="at">net.irradiance =</span> r_net</span>
<span id="cb116-5"><a href="#cb116-5" tabindex="-1"></a>       )</span></code></pre></div>
<pre><code>## [1] 0.9448297</code></pre>
<p>This function returns an estimate of reference evapotranspiration
expressed in mm / h. Can be used with hourly means for the inputs or
more frequent observations. In all cases the result is expressed as an
instantaneous water flux rate expressed per hour.</p>
<p>Function <code>ET_ref_day()</code> should be used when the input data
are daily meeans or less frequent.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
